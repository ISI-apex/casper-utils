Utilities for building CASPER and running experiments.

Build Gentoo Prefix with CASPER and dependencies
================================================

Step 1. Prepare source tarballs
------------------------------

To build Gentoo Prefix need to pre-populate `distfiles/` directory
with some special source tarballs (even if the build host is online).

All source tarballs are on USC HPCC filesystem in
`/scratch/acolin/casper-utils/distfiles/`, so you can just copy
all of it:

	$ rsync -aq /scratch/acolin/casper-utils/distfiles/ casper-utils/distfiles/

For offline build hosts (e.g. worker nodes on USC HPCC), the above copy
of the whole distfiles directory is a requirement. For online hosts, it
is sufficient to copy only the special tarballs listed below (however, if you
have access to all, then might as well copy all to not waste Internet
bandwidth).

The special source taballs that must be prepopulated, even for online build hosts:

* `portage-DATE.tar.bz2`
* `gentoo-DATE.tar.bz2`

  The snapshot date is indicated in the job script.  Cannot always be fetched
  from online, because upstream hosts only about 1 month.

* `gentoo-headers{,-base}-KERNEL_VERSION.tar.gz`

  Archives for the kernel version running on the host. The archives for 3.10
  are available in `distfiles/` (see below). To make an archive for other kernel
  versions, see the comments in the ebuild.

* `tetgen` (manually fill out form to get download link)
* `ampi` (manually fill out form to get download link)
* `pyop2` (due to checksum changes in tarball autogenerated by GitHub?)

Step 2. Run build job
---------------------
To build Gentoo Prefix on USC HPPC: `jobs/gpref.job.sh`

    $ casper-utils/jobs/gpref.job.sh PREFIX_PATH casper-usc-hpcc-ARCH ARCH

To build Gentoo Prefix on other hosts:

    $ casper-utils/jobs/gpref.sh PREFIX_PATH casper-usc-hpcc-ARCH

where
* the first argument (`PREFIX_PATH`) is a relative or absolute folder where
  the prefix will be built (ensure several GB of space, and note that after
  prefix is built it cannot be relocated to another path), on USC HPCC you
  most likely want this to be under /scratch or /scratch2 filesystem;
* the second argument is a Gentoo profile name where ARCH identifies the CPU
  family for which to optimize via the `-march,-mtune` compiler flags (for the
  generic unoptimized use `amd64`; for supported families see
 `ebuilds/profiles/casper-usc-hpcc-*`),
* the third argument (for USC HPCC only) ARCH again, but cannot be `amd64`;
  even if you want a generic (unoptimized) build, you still have to choose a
  CPU family for the build host (`sandybridge` is a reasonable choice for
  building a generic prefix, see notes below).

Some notes:

* Prefix with all CASPER dependencies takes about 6 hours to build
  on average 16 core box with a normal disk file system. On USC HPCC
  the same exact job takes about 24-48 hours due to slow shared
  filesystem (despite the build working directoies being in fast
  local /tmp directory).
* Due to imperfections in the build recipes for some libraries, the
  cpu family of the build host must be the same as that of the target host,
  i.e. if you want a prefix optimized for Sandy Bridge, you have to
  build it on a Sandy Bridge node. (This could be fixed by tracking down
  the offending packages and fixing each to not use target compiler flags
  for tools that need to be run on the build host.)
* Some packages optimize for the build host even if you did not request
  any optimization, so you can't build a generic unoptimized prefix on
  a new CPU family; use Sandy Bridge nodes to build generic prefixes that
  should mostly work on newer CPU families too.
* Builds of numerical libraries on AMD Opteron node appear to be broken
  when optimized for opteron CPU family (even with `-march=native`).

Step 3. Test the prefix
------------------------

The `test-prefix.sh` runs a CFD benchmark in FEniCS and Firedrake
with MPI and GPU.

To launch a job on USC HPCC worker node, run this launcher script
on the login node:

    $ bash exp/test-prefix/test-prefix.job.sh PREFIX_PATH ARCH GPU

where `PREFIX_PATH` is the directory with the prefix, ARCH is the CPU Family
(e.g. `sandybridge` see Step 2 above) with which the prefix is compatible and
GPU is the GPU model (e.g.  `k20`; look in `bin/pscommon.sh` for which
CPU families have which CPU models).

On another host (compatible with the ARCH for which the prefix was built):

    $ PREFIX_PATH/startprefix 
    $ mkdir -p casper-utils/exp/dat
    $ cd casper-utils/exp/dat
    $ bash ../jobs/test-prefix.sh

Enter the prefix
================

To build and run applications (or anything else) inside the prefix, it is in
theory sufficient to invoke the application by its full path, however it is
usually convenient to "enter" into the prefix, which adds the prefix binary
PATHs to the PATH env var and does other setup.

USC HPCC
--------

To enter the prefix on a USC HPCC host (login or worker with interactive shell):

    $ export PATH=ABSOLUTE_PATH_TO/casper-utils/bin:$PATH
    $ pstart PREFIX_PATH

To eneuque a job inside the prefix on a USC HPCC worker node:

    $ psbatch PREFIX_PATH ARCH GPU:GPU_COUNT NUM_NODES NUM_TASKS TIME_LIMIT command arg arg...

for example:

    $ psbatch /scratch/me/myprefix sandybridge "k20:1" 1 1 00:10:00 python --version

Generic Linux host
------------------

To enter the prefix on a generic Linux host:

    $ PREFIX_PATH/startprefix


Evaluate CASPER Auto-tuner
==========================

Experiments are available for evaluating CASPER Auto-Tuner
by first profiling the application performance and then using
these measurements to train a performance prediction model (as a function of
tunable parameter values) and evaluate the model on
a test subset of the profiling data. The experiments for
the followin benchmarks are available:
* `exp/tune-halide`: tune parameters in the Halide schedule for the blur filter
  Halide pipeline, evaluated for both a CPU target and a GPU target,
* `exp/tune-fenics`: tune number of ranks and threads
  in MPI+OpenMP linear solver operator in context of a 2D Lid-Driven Cavity
  Finite Element problem implemented in FEniCS framework.

All the dependencies (LLVM, Halide, OpenCL, etc) of this experiment are
already installed in the Prefix (see first chapter for building a prefix).
The following commands can be run inside the prefix: to enter the Prefix
see the previous chapter. If your system has all the dependencies of
the right versions (with the right patches, etc) installed, then the
following commands should work on your system too (without the Prefix),
but nasty build issues might arise that were already solved in the Prefix.

See `Makefile` in each experiment's directory all available make targets,
including the fine-grained targets for generated intermediate artifacts and for
cleaning; what follows is a brief summary. Multiple targets may be
passed to the same make command where appropriate.

To build and test the binaries for the Halide experiment:

    $ cd casper-utils/exp/tune-halide
    $ make
    $ make test

To generate a small profiling dataset for testing on CPU and GPU targets in
`*.csv` files and to train the respective prediction models:

    $ make model-small

To generate the large dataset (takes >24 hours) and train the prediction
models:

    $ make model-large

See `tune-halide/Makefile` for fine-grained make targets for generated
intermediate artifacts and for cleaning.


The FEniCS benchmark application is in Python and does not involve
an explicit compile step, the experiment can be run with:


    $ cd casper-utils/exp/tune-fenics
    $ make model-small

For larger profiling dataset (takes several hours to collect), there
are two options depening on how the datapoints along the input size
are spread: linearly ({2,4,6,...}), or geometrically ({2,4,16,...}):

    $ make model-lin-large
    $ make model-log-large
