Utilities for building CASPER and running experiments.

Step 0. Clone this repository recursively
------------------------------------------

This repository contains references to other repositories as git
submodules. To fetch the whole tree, clone recursively:

    $ git clone --recursive https://github.com/ISI-apex/casper-utils

If you already cloned non-recursively then simply do this:

    $ git submodule init
    $ git submodule update

Later, but before building, you'll need to checkout the latest release tag
appropriate for the system on which you are going to build. Building master
tip branch is not recommended, because it moves quickly and not every commit
is tested, so it is too likely for the build job to fail. Release tags have
been verified to build successfully to the end on the system mentioned in the
tag's release note. You can checkout a tag with:

    $ cd casper-utils
    $ git checkout TAG_IDENTIFIER
    $ git submodule update --rebase

Build Gentoo Prefix with CASPER and dependencies
================================================

A Gentoo Prefix is a way to manage dependencies installed from source with a
full-featured package manager without root on a system, hence particularly
useful on HPC clusters. Conceptually, in essence, it's a wrapper around
`./configure && make && make install`. Binaries built within the prefix may be
called from the host as any other binary (although it's usually useful to work
in a prefix shell, see below), and host binaries may be invoked from within the
prefix seemlessly. A Prefix allows everything to be independent of the host
distribution (prefix bootstrap is very robust and should boostrap on any Linux
system) and thus the versions of any of the software libraries, toolchains, and
applications may be chosen at will. A Prefix is a lot more useful than
Singularity or similar containers based on immutable images. The following
sections describe how to build a prefix on USC HPCC cluster and on other hosts.

Step 1. Prepare source tarballs
------------------------------

To build Gentoo Prefix need to pre-populate `distfiles/` directory
with some special source tarballs (even if the build host is online).

On some supported HPC clusters, the `distfiles/` directory can be copied
from a shared filesystem:
* On USC HPCC/Discovery clusters:

        $ rsync -aq /project/jpwalter_356/distfiles/ casper-utils/distfiles/

* On ANL Theta:

	$ rsync -aq /lus/theta-fs0/projects/CASPER/distfiles/ casper-utils/distfiles/

* On Oak Ridge Summit:

	$ rsync -aq /ccs/proj/csc436/distfiles/ casper-utils/distfiles/

* On the ISI gpuk40 machine:

        $ rsync -aq /home/casper/distfiles/ casper-utils/distfiles/

* On other hosts, the same directory is available as a tar archive, which needs
to be downloaded manually from the link below via a browser (or by using
`gdown` tool, `curl`/`wget` likely will not work due to Google intricacies)
and extracted at root of this repository:

        $ cd casper-utils
        $ gdown https://drive.google.com/uc?id=1nQqWsyeYBwCBA8gUdwSyjryr_OvSQFk1
        $ tar xf distfiles-20200604.tar

Regardless of on which system in the above list, make your copy writeable:

	$ chmod -R u+rw casper-utils/distfiles/

### Supplemental information: unfetchable tarballs

Online build hosts will automatically fetch tarballs from upstream (subject to
broken links or server downtime), but some tarballs (listed below) cannot be
fetched from upstream at all. So, even for online hosts, you have to obtain
the tarball directory as described above.

For reference, the special source tarballs that cannot be fetched from upstream:

* `portage-DATE.tar.bz2`
* `gentoo-DATE.tar.bz2`

  The snapshot date is indicated in the job script.  Cannot always be fetched
  from online, because upstream hosts only about 1 month.

* `gentoo-headers{,-base}-KERNEL_VERSION.tar.gz`

  Archives for the kernel version running on the host. The archives for 3.10
  are available in `distfiles/` (see below). To make an archive for other kernel
  versions, see the comments in the ebuild.

* `tetgen` (manually fill out form to get download link)
* `ampi` (manually fill out form to get download link)
* `pyop2` (due to checksum changes in tarball autogenerated by GitHub?)

Note: It is important to use `.tar.gz` archive format (not `.tar.bz2`)
for tarballs used during the stage 1 of bootstrap, because otherwise
the build host needs to have bzip2 installed (an extra dependency). In
the provided distfiles archive and directory, the format is `tar.gz`.

Step 2. Run build job
---------------------

In all sections that follow:

* the first argument (`PREFIX_PATH`) is a relative or absolute folder where
  the prefix will be built (ensure several GB of space, and note that after
  prefix is built it cannot be relocated to another path)
* the second argument is a Gentoo profile name specific to the given platform

***NOTE***: before building, remember to checkout the latest release verified
to build on the system that you're building on (see details in Step 0).

### USC HPCC or Discovery

Use this wrapper script to launch the build job on worker nodes:

    $ casper-utils/jobs/usc/gpref.job.sh PREFIX_PATH casper-usc-CLUSTER-ARCH CLUSTER[:PARTITION] ARCH

* the second argument is a Gentoo profile name where CLUSTER identifies the
  HPC cluster (usc-hpcc or usc-discovery) and ARCH identifies the CPU family
  for which to optimize via the `-march,-mtune` compiler flags (for the generic
  unoptimized use `amd64`; for supported clusters and cpu families see
  `ebuilds/profiles/casper-usc-*-*`),
* the third argument is the cluster name: either `discovery` or `hpcc`,
  optionally followed by colon and a partition name, e.g. `oneweek`.
* the fourth argument ARCH again, but cannot be `amd64`;
  even if you want a generic (unoptimized) build, you still have to choose a
  CPU family for the build host (`sandybridge` is a reasonable choice for
  building a generic prefix, see notes below).

### ANL Theta

On ANL Theta, the build can be done on a login machine:

    $ casper-utils/jobs/gpref.sh PREFIX_PATH casper-anl-theta-knl

### OLCF Summit

On OLCF Summit, choose `PREFIX_PATH` to be in the project work area backed by
the Spectrum Scale parallel filesystem (aka. "scratch"), not project or user
home file systems backed by NFS. This is because the work area has massive
amounts of space, and because NFS (used for home) creates problems with stale
`.nfsX` files and may not be the fastest when accessed from worker nodes.

The project work area has a 90 day file retention period, which means files are
deleted after they haven't been accessed for this long. To refresh file access
times and thus prevent the purge, run this every couple of months:

    $ find PREFIX_PATH -execdir touch -a {} \;

The build can be done on a worker node (preferred), run this command
on the login machine to submit the job:

        $ casper-utils/jobs/olcf-summit/gpref.job.sh PREFIX_PATH casper-olcf-summit

Or, the build can also be done directly on the login macine:

        $ casper-utils/jobs/gpref.sh PREFIX_PATH casper-olcf-summit

### Other Linux hosts

You might want to override the default for number of processors to use (the
default is what `nproc` returns).

    $ export NPROC=16

You may also want to override the default temporary build directory (the
default is the first one that has enough space from the list: `/tmp`,
`/dev/shm`):

    $ export TMPDIR=/path/to/custom/temp/dir

Run the build script directly:

    $ casper-utils/jobs/gpref.sh PREFIX_PATH casper-generic-ARCH

where the second argument is a Gentoo profile name where ARCH identifies the
CPU family for which to optimize via the `-march,-mtune` compiler flags. For
the generic unoptimized use `amd64`; for gpuk40 (Xeon E5-2670) use
`sandybridge`; for supported cpu families see
`ebuilds/profiles/casper-generic-*`).

### Tips and notes

A useful oneliner for monitoring the log from the latest job invocation
(especially useful when you have to re-invoke the job after fixing failures):

    ls -t PREFIX_PATH/var/log/prefix/*.{out,err} | head -2 | xargs tail -f

The job logs are saved in `PREFIX_PATH/var/log/prefix/`, and logs from
the bootstrap step are also in `PREFIX_PATH/stage{1,2,3}.log`.

Some notes:

* Prefix with all CASPER dependencies takes about 6 hours to build
  on average 16 core box with a normal disk file system. On USC HPCC
  the same exact job takes about 24-48 hours due to slow shared
  filesystem (despite the build working directories being in fast
  local /tmp directory).
* Due to imperfections in the build recipes for some libraries, the
  cpu family of the build host must be the same as that of the target host,
  i.e. if you want a prefix optimized for Sandy Bridge, you have to
  build it on a Sandy Bridge node. (This could be fixed by tracking down
  the offending packages and fixing each to not use target compiler flags
  for tools that need to be run on the build host.)
* Some packages optimize for the build host even if you did not request
  any optimization, so you can't build a generic unoptimized prefix on
  a new CPU family; use Sandy Bridge nodes to build generic prefixes that
  should mostly work on newer CPU families too.
* Builds of numerical libraries on AMD Opteron node appear to be broken
  when optimized for opteron CPU family (even with `-march=native`).
* By default the temporary work directory is removed automatically
  (including when job fails). To keep the dir, set `KEEP_TMPDIR` env
  var to a non-empty value. This is not useful when the build runs on
  a worker node (because not easy to get to the local file system of
  that node after job exists), as is the case on USC HPCC.

Step 3. Test the prefix
------------------------

### Minimal smoke test

The minimal test is to enter the prefix shell (more details on entering the
prefix are in a dedicated section below):

    $ cd PREFIX_PATH
    $ ./startprefix

A new shell should be opened, now try run a program within the prefix:

    $  emerge --version
    Portage 2.3.100 ...

If this smoke test was not successful, check the logs for any errors (see
previous step for log file locations). Errors in later stages, may be fixed by
entering the prefix shell and using portage (`emerge`) to diagnose. Then,
the top-level job may be restarted (as described in previous step), and
it should resume incrementally.

### Application test

The are two tests available:
1. `test-mpi`: a hello-world MPI test on two nodes with two ranks on each
2. `test-cfd`: a CFD benchmark in FEniCS and Firedrake with MPI and GPU.

First, build the `mpitest` application:

    $ cd casper-utils/exp/apps/mpitest
    $ PREFIX_PATH/startprefix
    $ make

Check that it was linked correctly against libraries strictly only within the
prefix path:

    $ ldd ./mpitest


#### On USC HPCC

To launch a job on USC HPCC worker node, run this launcher script
on the login node:

    $ bash exp/test-prefix/test-mpi.job.sh PREFIX_PATH CLUSTER ARCH
    $ bash exp/test-prefix/test-cfd.job.sh PREFIX_PATH CLUSTER ARCH:GPU

where `PREFIX_PATH` is the directory with the prefix, CLUSTER is the
name of the compute cluster (e.g. `discovery` see Step 2 above), ARCH is the
CPU Family (e.g. `sandybridge` see Step 2 above) with which the prefix is
compatible and GPU is the GPU model (e.g.  `p100`), run `psfeat` tool from
`casper-utils/bin/` to see the nodes and their GPU resources (do not include
the `gpu:` prefix and do not include the `:N` count suffix).

These scripts will keep running (watching the log files) even after the job
completes (they do not detect job completion), so you have to Ctrl-C when you
see that the job has finished. To check success, check the end of the log for
(but also check for expected output and lack of any errors):

    Leaving Gentoo Prefix with exit status 0

Also, the script just watches the log file, after the job has launched, you
can kill the script with Ctrl-C, and the job will keep running. You can then
manually check the queue with `squeue` and monitor the job log files the
paths to which where printed when the job was run (look for `--output` and
`--error` arguments in the log).

#### On Argonne Theta

Enqueue a job (in this example, in interactive mode):

    qsub -A CASPER -n 2 -t 10 -I

In the job's shell on the "MOM" node, first add the special wrapper scripts to
`PATH`:

    $ export EPREFIX=/absolute/path/to/prefix
    $ export PATH=/absolute/path/to/casper-utils/bin/theta:$PATH

Then procede to run the `test-*.job.sh` test scripts as in the instructions for
USC HPCC above.

#### On a generic host

On a host (compatible with the ARCH for which the prefix was built):

    $ PREFIX_PATH/startprefix 
    $ mkdir -p casper-utils/exp/dat
    $ cd casper-utils/exp/dat
    $ bash ../jobs/test-mpi.sh

The `test-cfd.sh` script takes one optional argument that enables
the test on GPU (besides the non-GPU tests) when non-empty:

    $ bash ../jobs/test-cfd.sh 1


Note: As oppsoed on the cluster (see above), on a generic host, the `test-mpi`
will only test one node. Modify the script if you want something different.

Enter the prefix
================

To build and run applications (or anything else) inside the prefix, it is in
theory sufficient to invoke the application by its full path, however it is
usually convenient to "enter" into the prefix, which adds the prefix binary
PATHs to the PATH env var and does other setup.

USC HPCC
--------

To enter the prefix on a USC HPCC host (login or worker with interactive shell):

    $ PREFIX_PATH/ptools/pstart

To enqueue a job inside the prefix on a USC HPCC worker node:

    $ PREFIX_PATH/ptools/psbatch CLUSTER[:PARTITION] ARCH[:GPU:GPU_COUNT] MAX_MEM_PER_TASK \
	NUM_NODES NUM_TASKS_PER_NODE TIME_LIMIT command arg arg...

for example:

    $ PREFIX_PATH/ptools/psbatch hpcc sandybridge:k20:1 all 1 1 00:10:00 python --version

The keyword 'all' for `MAX_MEM_PER_TASK` grants all memory on the node
("per task" does not apply anymore).

Generic Linux host
------------------

To enter the prefix on a generic Linux host:

    $ PREFIX_PATH/startprefix

Tips for maintaining the Prefix
===============================

On a cluster, Portage (the package manager) tools (`emerge`, `equery`,
`ebuild` `eix`) can be used from login machine if the prefix was built
unoptimized for a particular architecture (i.e. the `*-amd64` profile), and
if some care is taken as described below.

On USC Discovery cluster, invoke portage tools through the wrapper `p4port` on
the login machine and `pport` on the worker nodes, like so:

    p4port emerge app-portage/prefix-tools

The wrapper takes care of setting the build directory to a temporary
directory in tmpfs (for speed and for working around inability to build
on BeegFS due to lacking hard link support), and of setting number of
parallel processes to use appropriately.

Fetching sources
----------------

By default, online fetching is disabled (which is appropriate when running
portage from . To enable it comment out `EVCS_OFFLINE=1` from
`$EPREFIX/etc/portage/make.conf`.

Updating
--------

Not that each Prefix directory is standalone and does not reference the
`casper-utils` directory that was used to build the prefix. Updating an
existing Prefix and pulling new commits to `casper-utils`repo are unrelated
operations.

To update the casper overlay, which involves rebuilding any packages that
have changed (and their downstream dependencies requering a rebuild),
enter the overlay directory:

    cd $EPREFIX/var/db/repos/casper

The first time, add the remote for convenience (note: the remote pointing
into casper-utils/ebuilds is needed only for boostrap, and if you want
to commit a new snapshot of ebuilds to casper-utils):

    git remote add up git@github.com:ISI-apex/casper-ebuilds.git

Pull the changes:

    git pull --ff-only up master

On a login machine, first enable online fetching (see subsection above), then
tell portage to figure out what needs to be rebuilt and fetch the sources:

    p4port emerge -f --ask -uDU --keep-going --with-bdeps=y @world

On USC Discovery, the build should be done on a worker node, not on the
shared login machine where CPU usage limits are enforced. To schedule
a job:

    $EPREFIX/ptools/psbatch discovery ARCH 1 16 02:00:00 \
	pport emerge -uDU --keep-going --with-bdeps=y @world

where ARCH is the architecture for which the prefix was built (or `any`
for an unoptimized prefix). Partition may be specified by appending a suffix
to the first argument like `discovery:oneweek`.

The job will remain in SLURM queue even if the `psbatch` script is killed
(including even if the login node is rebooted).

If your prefix is not optimized for a particular architecture, and if when you
do the first `emerge -f` on the login machine, you see that the packages
that are being updated are quick to build (e.g. python packages without a
compilation step at all, or small packages quick to compile), then you can
just run the second `emerge` on the login machine too:

    $EPREFIX/ptools/pstart p4port emerge -uDU --keep-going --with-bdeps=y @world

Live package versions
---------------------

To enable "live" versions a package (master tip from VCS, which will change
every time you re-emerge the package), which may be useful for some packages
provided by the casper overlay, add to
`$EPREFIX/etc/protage/package.accept_keywords` packages in the following
format:

    app-portage/prefix-tools **

Troubleshooting: errors about manifests
---------------------------------------

If `emerge` complains about a manifest file (the warning is non-fatal, but do
not ignore it, do not procede with the operation if get warning), this means
that whoever committed a change to a package ebuild recipe did not regenerate
the manifest (bad). To regenerate the manifest, run a command like so for the
respective package:

    p4port ebuild app-portage/prefix-tools/prefix-tools-9999.ebuild manifest

Troubleshooting: emerge/ebuild hangs
------------------------------------

If emerge is waiting for a lock to be released (it will say so), then
it might be due to a previous emerge/ebuild not having completed cleanly,
so try manually cleanup the lock file (after checking for any portage
processes that might still be running):

    rm $EPREFIX/var/db/.pkg.portage_lockfile

If emerge or ebuild hangs at the very end of a merge without any relevant
output, it may be due to file system issues (especially when running on
networked filesystems of various kinds). Try disable the `sync` that is called
after merging (and has been observed to hang on NFS):

    FEATURES="-merge-sync" emerge ...

Evaluate CASPER Auto-tuner
==========================

Experiments are available for evaluating CASPER Auto-Tuner
by first profiling the application performance and then using
these measurements to train a performance prediction model (as a function of
tunable parameter values) and evaluate the model on
a test subset of the profiling data. The experiments for
the following benchmarks are available:
* `exp/tune-halide`: tune parameters in the Halide schedule for the blur filter
  Halide pipeline, evaluated for both a CPU target and a GPU target,
* `exp/tune-fenics`: tune number of ranks and threads
  in MPI+OpenMP linear solver operator in context of a 2D Lid-Driven Cavity
  Finite Element problem implemented in FEniCS framework.

All the dependencies (LLVM, Halide, OpenCL, etc) of this experiment are
already installed in the Prefix (see first chapter for building a prefix).
The following commands can be run inside the prefix: to enter the Prefix
see the previous chapter. If your system has all the dependencies of
the right versions (with the right patches, etc) installed, then the
following commands should work on your system too (without the Prefix),
but nasty build issues might arise that were already solved in the Prefix.

See `Makefile` in each experiment's directory all available make targets,
including the fine-grained targets for generated intermediate artifacts and for
cleaning; what follows is a brief summary. Multiple targets may be
passed to the same make command where appropriate.

Tune Halide schedule
---------------------

To build and test the binaries for the Halide experiment:

    $ cd casper-utils/exp/tune-halide
    $ make
    $ make test

To perform a quick smoke-test (does not produce a useful model), generate a
small profiling dataset and train the respective prediction models:

    $ make model-small

To generate the large dataset (takes >24 hours) and train the prediction
models:

    $ make model-large

See `tune-halide/Makefile` for fine-grained make targets for generated
intermediate artifacts and for cleaning.

Tune MPI+OpenMP params in linear solver in FEniCS FEM program
--------------------------------------------------------------

The FEniCS benchmark application is in the following directory, and is written
in Python so does not involve an explicit compile step


    $ cd casper-utils/exp/tune-fenics

The perform a quick smoke-test (does not produce a useful model):

    $ make model-small

For larger profiling dataset (takes several hours to collect), there
are two options depending on how the datapoints along the input size
are spread: linearly ({2,4,6,...}), or geometrically ({2,4,16,...}):

    $ make model-lin-large
    $ make model-log-large

Evaluation of the model
-----------------------

When performance prediction models finish training and testing, a few metrics
will be printed:

* MAE: mean absolute error
* MSE: mean squared error
* MAPE(>*x* s): mean absolute percentage error, restricting to data instances
  whose runtime is greater than *x* seconds

*Note: the reason to exclude data instances with small runtime is that
sometimes MAPE gets extremely large (>1000%) when the actual runtime is small.
In addition, we care more about tasks with a large runtime in the scheduling
process.*

* rho: Spearman's rank correlation coefficient (or Spearman's rho), which
  indicates if a higher ranked candidate through prediction also has a higher
ranked true runtime. In short, how well does our model tell about the order of
runtimes.

The speedup from best parameter values over poorest or over average parameter
values can be plotted using scripts in `exp/tune/`, however at the moment, the
raw data output by the previous steps needs to be manually post-processed to
extract aggregated maximum/minimum/etc values.

Build applications
===================

There are several applications written in CASPER in `exp/apps/casper/`.
To build and run them, first enter the Prefix as described in an earlier
section (builds have not been tested on other systems, i.e. outside of the
Prefix).

To build, first build the CASPER compiler (must use Clang for all builds):

    cd compiler
    mkdir build && cd build
    CXX=clang++ CC=clang cmake ..
    make

Then, build an app against this build of CASPER, for example for the SAR app:

    cd exp/apps/casper/halide-sar-app/casper
    mkdir build && cd build
    CXX=clang++ CC=clang cmake ..
    make
    make sarbp.run

The app is a separate CMake project, and it contains a relative path to the
CASPER compiler directory assuming the structure of this parent repository.
The CASPER installation in the system/prefix takes precedence over this hint.
